<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>基于GitLab 的 CI 实践 (docker) · ShaofeiZi Blog · 做个日常记录</title>
    <meta name="description" content="訾绍飞的博客。万物皆有裂缝处，那是光射进来的地方。">
    <link rel="shortcut icon" href="/BLOG/favicon.ico">
  <link rel="manifest" href="/BLOG/manifest.json">
  <meta name="theme-color" content="#3F51B5">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/BLOG/icons/192.png">
  <link rel="mask-icon" href="/BLOG/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/192.png">
  <meta name="msapplication-TileColor" content="#3F51B5">
    
    <link rel="preload" href="/BLOG/assets/css/styles.0f06c689.css" as="style"><link rel="preload" href="/BLOG/assets/js/app.0f06c689.js" as="script"><link rel="preload" href="/BLOG/assets/js/8.8d991ea8.js" as="script"><link rel="prefetch" href="/BLOG/assets/js/1.63593f8f.js"><link rel="prefetch" href="/BLOG/assets/js/10.fdd39873.js"><link rel="prefetch" href="/BLOG/assets/js/11.8a622b5e.js"><link rel="prefetch" href="/BLOG/assets/js/12.e9c56306.js"><link rel="prefetch" href="/BLOG/assets/js/13.20e44605.js"><link rel="prefetch" href="/BLOG/assets/js/14.eb804906.js"><link rel="prefetch" href="/BLOG/assets/js/15.47582e90.js"><link rel="prefetch" href="/BLOG/assets/js/16.0861cf41.js"><link rel="prefetch" href="/BLOG/assets/js/17.417e8e0e.js"><link rel="prefetch" href="/BLOG/assets/js/18.2318cd37.js"><link rel="prefetch" href="/BLOG/assets/js/19.997f9e1c.js"><link rel="prefetch" href="/BLOG/assets/js/2.73ec8147.js"><link rel="prefetch" href="/BLOG/assets/js/20.a8cf0c8f.js"><link rel="prefetch" href="/BLOG/assets/js/21.88823ca0.js"><link rel="prefetch" href="/BLOG/assets/js/22.a2e20a79.js"><link rel="prefetch" href="/BLOG/assets/js/23.e7d1e135.js"><link rel="prefetch" href="/BLOG/assets/js/24.492e8390.js"><link rel="prefetch" href="/BLOG/assets/js/25.b31904c7.js"><link rel="prefetch" href="/BLOG/assets/js/26.36e1cf84.js"><link rel="prefetch" href="/BLOG/assets/js/27.94b05a58.js"><link rel="prefetch" href="/BLOG/assets/js/28.bdcf9b24.js"><link rel="prefetch" href="/BLOG/assets/js/29.e41d34d2.js"><link rel="prefetch" href="/BLOG/assets/js/3.a4d6da98.js"><link rel="prefetch" href="/BLOG/assets/js/30.ba1f5d39.js"><link rel="prefetch" href="/BLOG/assets/js/31.2bd2d3d8.js"><link rel="prefetch" href="/BLOG/assets/js/32.824499f7.js"><link rel="prefetch" href="/BLOG/assets/js/33.58645df0.js"><link rel="prefetch" href="/BLOG/assets/js/34.334e4a83.js"><link rel="prefetch" href="/BLOG/assets/js/35.aa96d72d.js"><link rel="prefetch" href="/BLOG/assets/js/36.40c509d3.js"><link rel="prefetch" href="/BLOG/assets/js/37.829377f5.js"><link rel="prefetch" href="/BLOG/assets/js/38.3b15ddc7.js"><link rel="prefetch" href="/BLOG/assets/js/39.87218167.js"><link rel="prefetch" href="/BLOG/assets/js/4.c66c6308.js"><link rel="prefetch" href="/BLOG/assets/js/40.63562db5.js"><link rel="prefetch" href="/BLOG/assets/js/41.168fcabb.js"><link rel="prefetch" href="/BLOG/assets/js/42.e8f3ecd2.js"><link rel="prefetch" href="/BLOG/assets/js/43.5eb65461.js"><link rel="prefetch" href="/BLOG/assets/js/44.41e08b42.js"><link rel="prefetch" href="/BLOG/assets/js/45.54b7df8d.js"><link rel="prefetch" href="/BLOG/assets/js/46.0a0de71e.js"><link rel="prefetch" href="/BLOG/assets/js/47.bd587f67.js"><link rel="prefetch" href="/BLOG/assets/js/48.f3af8d7e.js"><link rel="prefetch" href="/BLOG/assets/js/49.483980fa.js"><link rel="prefetch" href="/BLOG/assets/js/5.05c034ec.js"><link rel="prefetch" href="/BLOG/assets/js/50.f814132b.js"><link rel="prefetch" href="/BLOG/assets/js/51.477c87bb.js"><link rel="prefetch" href="/BLOG/assets/js/52.55f963c5.js"><link rel="prefetch" href="/BLOG/assets/js/53.9eafd57f.js"><link rel="prefetch" href="/BLOG/assets/js/54.be1ba528.js"><link rel="prefetch" href="/BLOG/assets/js/55.a0ef8049.js"><link rel="prefetch" href="/BLOG/assets/js/56.8e8dca35.js"><link rel="prefetch" href="/BLOG/assets/js/6.f61c2d7b.js"><link rel="prefetch" href="/BLOG/assets/js/7.acadab6a.js"><link rel="prefetch" href="/BLOG/assets/js/9.efa09c0d.js">
    <link rel="stylesheet" href="/BLOG/assets/css/styles.0f06c689.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="application theme--light"><div class="application--wrap"><div role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" class="v-progress-linear blog-progress" style="height:3px;display:none;"><div class="v-progress-linear__background accent" style="height:3px;opacity:0.4;width:100%;"></div><div class="v-progress-linear__bar"><!----><div class="v-progress-linear__bar__determinate accent" style="width:0%;"></div></div></div><aside class="v-navigation-drawer v-navigation-drawer--close v-navigation-drawer--fixed v-navigation-drawer--is-mobile theme--light" style="height:100%;margin-top:0px;transform:translateX(-240px);width:240px;"><div><div class="aside-brand-wrap"><div class="aside-brand"><a href="/BLOG/" class="aside-avatar elevation-2 router-link-active"><img src="/BLOG/face.png" alt="avatar"></a><hgroup class="mt-3 variant-hide"><div class="subheading white--text">訾绍飞</div><a href="mailto:zishaofei221@gmail.com" title="zishaofei221@gmail.com" class="aside-mail primary--text text--lighten-5">zishaofei221@gmail.com</a></hgroup></div></div><hr class="v-divider theme--dark"><div role="list" class="v-list nav-list theme--light"><div role="listitem"><a href="/BLOG/" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-home"></i></div></div><div class="v-list__tile__content">首页</div></a></div><div role="listitem"><a href="/BLOG/tags" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-tag"></i></div></div><div class="v-list__tile__content">标签</div></a></div><div role="listitem"><a href="https://github.com/ShaofeiZi" target="_blank" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fab fa-github"></i></div></div><div class="v-list__tile__content">Github</div></a></div><div role="listitem"><a href="/BLOG/about" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-user-secret"></i></div></div><div class="v-list__tile__content">About</div></a></div></div></div><div class="v-navigation-drawer__border"></div></aside><nav class="blog-toolbar v-toolbar v-toolbar--fixed theme--dark primary" style="margin-top:0px;padding-right:0px;padding-left:0px;transform:translateY(0px);"><div class="v-toolbar__content" style="height:56px;"><button type="button" class="v-btn v-btn--icon theme--dark"><div class="v-btn__content"><i class="fa fa-bars"></i></div></button><div class="v-toolbar__title">基于GitLab 的 CI 实践 (docker)</div><div class="spacer"></div><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><div class="v-menu v-menu--inline" style="display:none;"><div class="v-menu__activator"><button type="button" class="v-btn v-btn--icon theme--dark"><div class="v-btn__content"><i class="fa fa-share-alt"></i></div></button></div><div class="v-menu__content theme--light " style="max-height:auto;min-width:0px;max-width:auto;top:12px;left:0px;transform-origin:top right;z-index:0;display:none;"><div role="list" class="v-list theme--light"><div role="listitem"><a class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-lg fa-copy"></i></div></div><div class="v-list__tile__title">复制链接</div></a></div></div><input type="text" tabindex="-1" aria-hidden="true" value="" class="fake-hide"></div></div></div></nav><main class="v-content" style="padding-top:56px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-content__wrap"><div class="container blog-container grid-list-xl align-center"><div class="layout row wrap"><div class="flex mb-3 xs12"><article class="v-card v-sheet theme--light elevation-16 post-card"><div class="v-card__title"><div class="flex xs12"><h2 class="display-1 mb-3">基于GitLab 的 CI 实践 (docker)</h2><div class="post-meta"><time datetime="2018-07-24T21:15:53.000Z" class="secondary--text post-time">2018年07月25日</time></div></div></div><div class="v-card__text pt-0 pb-0"><div class="flex xs12"><div class="content custom"><h1 id="gitlabci"><a href="#gitlabci" aria-hidden="true" class="header-anchor">#</a> GitlabCi</h1><p>基于GitLab 的 CI 实践。分享内容以 GitLab Community Edition 11.0.4 edb037c 为例。
</p><h2 id="为何选择-gitlab-ci"><a href="#为何选择-gitlab-ci" aria-hidden="true" class="header-anchor">#</a> 为何选择 GitLab CI</h2><h3 id="认识-gitlab-ci"><a href="#认识-gitlab-ci" aria-hidden="true" class="header-anchor">#</a> 认识 GitLab CI</h3><h4 id="什么是-gitlab-ci"><a href="#什么是-gitlab-ci" aria-hidden="true" class="header-anchor">#</a> 什么是 GitLab CI</h4><p>GitLab CI 是 GitLab 为了提升其在软件开发工程中作用，完善 DevOPS 理念所加入的 CI/CD 基础功能。可以便捷的融入软件开发环节中。通过 GitLab CI 可以定义完善的 CI/CD Pipeline。</p><h4 id="优势"><a href="#优势" aria-hidden="true" class="header-anchor">#</a> 优势</h4><ul><li>GitLab CI 是默认包含在 GitLab 中的，我们的代码使用 GitLab 进行托管，这样可以很容易的进行集成</li><li>GitLab CI 的前端界面比较美观，容易被人接受</li><li>包含实时构建日志，容易追踪</li><li>采用 C/S 的架构，可方面的进行横向扩展，性能上不会有影响</li><li>使用 YAML 进行配置，任何人都可以很方便的使用。</li></ul><h3 id="重点概念"><a href="#重点概念" aria-hidden="true" class="header-anchor">#</a> 重点概念</h3><h4 id="pipeline"><a href="#pipeline" aria-hidden="true" class="header-anchor">#</a> Pipeline</h4><p>Pipeline 相当于一个构建任务，里面可以包含多个流程，如依赖安装、编译、测试、部署等。
任何提交或者 Merge Request 的合并都可以触发 Pipeline</p><h4 id="stages"><a href="#stages" aria-hidden="true" class="header-anchor">#</a> Stages</h4><p>Stage 表示构建的阶段，即上面提到的流程.</p><ul><li>所有 Stages 按顺序执行，即当一个 Stage 完成后，下一个 Stage 才会开始</li><li>任一 Stage 失败，后面的 Stages 将永不会执行，Pipeline 失败</li><li>只有当所有 Stages 完成后，Pipeline 才会成功</li></ul><h4 id="jobs"><a href="#jobs" aria-hidden="true" class="header-anchor">#</a> Jobs</h4><p>Job 是 Stage 中的任务.</p><ul><li>相同 Stage 中的 Jobs 会并行执行</li><li>任一 Job 失败，那么 Stage 失败，Pipeline 失败</li><li>相同 Stage 中的 Jobs 都执行成功时，该 Stage 成功</li></ul><p>好的，基本的概念已经和大家介绍了， 大家可以发现，上面说的概念，没有提到任务的实际执行者. 那任务在哪里执行呢？</p><h3 id="gitlab-runner"><a href="#gitlab-runner" aria-hidden="true" class="header-anchor">#</a> GitLab runner</h3><p>Runner 是任务的实际执行者， 可以在 MacOS/Linux/Windows 等系统上运行。使用 golang 进行开发。 同时也可部署在 k8s 上</p><p>上面的示例为将 runner 注册为一个容器， 当然 大家也可以直接在物理机上执行。 在物理机上的注册方式与注册为容器大致相同</p><pre class="language-text"><code>sudo gitlab-runner register \
  --non-interactive \
  --url &quot;https://gitlab.com/&quot; \
  --registration-token &quot;PROJECT_REGISTRATION_TOKEN&quot; \
  --executor &quot;docker&quot; \
  --docker-image alpine:3 \
  --description &quot;docker-runner&quot; \
  --tag-list &quot;docker,aws&quot; \
  --run-untagged \
  --locked=&quot;false&quot; \
（这段代码来自官方文档）
</code></pre><p>接下来，我们来看下 runner 的类型， 以便在使用时进行区分。</p><h4 id="类型"><a href="#类型" aria-hidden="true" class="header-anchor">#</a> 类型</h4><ul><li>Shared - Runner runs jobs from all unassigned projects</li><li>Group - Runner runs jobs from all unassigned projects in its group</li><li>Specific - Runner runs jobs from assigned projects</li><li>Locked - Runner cannot be assigned to other projects</li><li>Paused - Runner will not receive any new jobs
大家在项目的 settings-- CI/CD -- Runners settings  即可查看</li></ul><p>当注册完成后，我们可以看下runner 的配置。</p><pre class="language-text"><code>sudo docker exec -it gitlab-runner /bin/sh
cat /etc/gitlab-runner/config.toml
</code></pre><p>首先最外层的是全局配置， 默认会有
concurrent = 1
check_interval = 0
这两个。 比较需要关注的是下面几个</p><h5 id="全局配置"><a href="#全局配置" aria-hidden="true" class="header-anchor">#</a> 全局配置</h5><p>concurrent: 并发数, 0 为无限制
sentry_dsn：与 Sentry 联动，可以将异常等收集至 Sentry 中。
listen_address: 暴露出 metrics 供 Prometheus 监控</p><p>接下来是 runner 的配置部分， 里面涉及的概念，我们先来了解一下。</p><h4 id="executor"><a href="#executor" aria-hidden="true" class="header-anchor">#</a> Executor</h4><ul><li>Shell</li><li>Docker (本次的分享内容)</li><li>Docker Machine and Docker Machine SSH (autoscaling)</li><li>Parallels</li><li>VirtualBox</li><li>SSH</li><li>Kubernetes (推荐)</li></ul><p>可以看到， 我们刚才将 runner 注册为了一个 docker 容器， 而现在选择 executor 为 Docker ， 那是什么意思呢？ 这意味着 我们在 Docker 里面启动另外的 Docker 容器，即 Docker In Docker</p><h3 id="概述"><a href="#概述" aria-hidden="true" class="header-anchor">#</a> 概述</h3><p>Docker In Docker 简称 dind，在 GitLab CI 的使用中，可能会常被用于 service 的部分。 dind 表示在 Docker 中实际运行了一个 Docker 容器, 或 Docker daemon。</p><p>其实如果只是在 Docker 中执行 docker 命令， 那装个二进制文件即可。 但是如果想要运行 Docker daemon (比如需要执行 docker info)或者访问任意的设备都是不允许的。</p><p>Docker 在 run 命令中提供了两个很重要的选项 --privileged 和 --device ， 另外的选项比如 --cap-add 和 --cap-drop 跟权限也很相关，不过不是今天的重点，按下不表。</p><p>--device 选项可以供我们在不使用 --privileged 选项时，访问到指定设备, 比如 docker run --device=/dev/sda:/dev/xvdc --rm -it ubuntu fdisk  /dev/xvdc 但是这也只是有限的权限， 我们知道 docker 的技术实现其实是基于 cgroup 的资源隔离，而 --device 却不足于让我们在容器内有足够的权限来完成 docker daemon 的启动。</p><p>在 2013年 左右， --privileged 选项被加入 docker， 这让我们在容器内启动容器变成了可能。 虽然 --privileged 的初始想法是为了能让容器开发更加便利，不过有些人在使用的时候，其实可能有些误解。</p><p>有时候，我们可能只是想要能够在容器内正常的build 镜像，或者是与 Docker daemon 进行交互，例如 docker images 等命令。 那么，我们其实不需要 dind， 我们需要的是 Docker Out Of Docker，即 dood，在使用的时候，其实是将 docker.sock 挂载入容器内</p><p>例如， 使用如下命令：</p><pre class="language-text"><code>sudo docker run --rm -ti -v /var/run/docker.sock:/var/run/docker.sock taobeier/docker /bin/sh  
</code></pre><p>在容器内可进行正常的docker images 等操作， 同时需要注意，在容器内的动作，将影响到 宿主机上的 docker daemon</p><p>关于 dood 的部分，我们先说这么多，我们回到 dind 中， 看下如何实现</p><h3 id="如何实现"><a href="#如何实现" aria-hidden="true" class="header-anchor">#</a> 如何实现</h3><ul><li>创建组和用户，并将用户加入该组。 使用 groupadd 和 useradd 命令</li><li>更新 subuid 和 subgid 文件， 将新用户和组配置到 /etc/subgid 和 /etc/subuid 文件中。 subuid 和 subgid 规定了允许用户使用的从属id</li><li>接下来需要挂载 /sys/kernel/security 为 securityfs 类型可以使用 mountpoint 命令进行测试 mountpoint /sys/kernel/security 如果不是一个挂载点， 那么使用 mount -t securityfs none /sys/kernel/security 进行挂载。如果没有挂载成功的话， 可以检查是否是 SELinux 或者 AppArmor 阻止了这个行为。这里详细的安全问题，可以参考 Linux Security Modules (LSM)</li><li>接下来允许 dockerd 命令启动 daemon 即可， dockerd --host=unix:///var/run/docker.sock --host=tcp://0.0.0.0:2375 即可将docker daemon 监听至 2375 端口</li></ul><p>以上的实现方式，可能会觉得有些复杂， 那么我们可以使用更加简单的办法</p><h3 id="简单做法"><a href="#简单做法" aria-hidden="true" class="header-anchor">#</a> 简单做法</h3><p>可以直接使用 Docker 官方镜像仓库中的 docker:dind 镜像, 但是在运行时， 需要指定 --privileged 选项</p><p>简单来说，只要</p><pre class="language-text"><code>sudo docker run --rm -ti --privileged  taobeier/docker:stable-dind /bin/sh
</code></pre><p>即可实现 dind 了， 进入镜像内， 执行 dockerd 即可看到效果</p><p>接下来，我们进入到 CI 实践的部分。 还是要继续看下runner 的配置</p><pre class="language-text"><code>[[runners]]
  name = &quot;docker&quot;
  url = &quot;https://gitlab.example.com/&quot;
  token = &quot;TOKEN&quot;
  limit = 0
  executor = &quot;docker&quot;
  builds_dir = &quot;&quot;
  shell = &quot;&quot;
  environment = [&quot;ENV=value&quot;, &quot;LC_ALL=en_US.UTF-8&quot;]
  clone_url = &quot;http://172.17.0.4&quot;
</code></pre><p>由于网络原因， clone_url 可以配置为可访问的地址，这样代码 clone 的时候，将会使用配置的这个地址。实际请求为</p><blockquote><p>http://gitlab-ci-token:TOKEN@172.17.0.4/namespace/project.git</p></blockquote><p>这个使用场景，在私有 gitlab 域名未解析的情况会比较有用 （当然 我之前确实遇到了这个情况）</p><ul><li>再看一下 runners.docker 的配置，这部分将影响 docker 的实际运行</li></ul><pre class="language-text"><code>[runners.docker]
  host = &quot;&quot;
  hostname = &quot;&quot;
  tls_cert_path = &quot;/home/tao/certs&quot;
  image = &quot;docker&quot;
  dns = [&quot;8.8.8.8&quot;]
  privileged = false
  userns_mode = &quot;host&quot;
  devices = [&quot;/dev/net/tun&quot;]
  disable_cache = false
  wait_for_services_timeout = 30
  cache_dir = &quot;&quot;
  volumes = [&quot;/data&quot;, &quot;/home/project/cache&quot;]
  extra_hosts = [&quot;other-host:127.0.0.1&quot;]
  services = [&quot;mongo&quot;, &quot;redis:3&quot;]
  allowed_images = [&quot;go:*&quot;, &quot;python:*&quot;, &quot;java:*&quot;]
</code></pre><p>dns, privileged, extra_hosts, services 比较关键， 尤其是在生产中网络情况多种多样， 需要格外关注。 至于 devices 配置 ，在今儿分享的一开始已经讲过了， allowed_images 的话， 是做了个限制。
上面几个配置项， 用过 docker 的同学，应该很容易理解。 我们来看下 services 这个配置项</p><p>如果使用了 dind 的方式， 大家可能会常常看到 有人在 .gitlab-ci.yml 中配置了 service: docker:dind , 那这是什么意思呢</p><p>services 的本质其实是使用了 docker 的 --link ，我们来看下它在 docker executor下如何工作</p><h3 id="docker-executor-如何工作"><a href="#docker-executor-如何工作" aria-hidden="true" class="header-anchor">#</a> Docker Executor 如何工作</h3><ul><li>创建 service 容器 (已经配置在 service 中的镜像)</li><li>创建 cache 容器 (存储已经配置在 config.toml 的卷和构建镜像的 Dockerfile)</li><li>创建 build 容器 并且 link 所有的 service 容器.</li><li>启动 build 容器 并且发送 job 脚本到该容器中.</li><li>执行 job 的脚本.</li><li>检出代码: /builds/group-name/project-name/.</li><li>执行 .gitlab-ci.yml 中定义的步骤.</li><li>检查脚本执行后的状态码，如果非 0 则构建失败.</li><li>移除 build 和 service 容器.</li></ul><p>看到这里， 大家应该能明白， service 其实和我们在 docker-compose 里面定义的 services 类似， 也就是说， 不仅可以定义 docker:dind 还可以使用 mysql， redis 等</p><p>聊完了以上的部分后，我们来看下生产中，我们还会遇到的问题。 首先就是 我们通常会使用私有镜像仓库</p><h3 id="私有镜像源"><a href="#私有镜像源" aria-hidden="true" class="header-anchor">#</a> 私有镜像源</h3><p>用户认证需要 GitLab Runner 1.8 或更高版本，在 0.6 ~ 1.8 版本之间的 Runner 需要自行去 Runner 的机器上手动执行。</p><p>默认情况下，如果访问的镜像仓库需要认真的话， GitLab Runner 会使用 DOCKER_AUTH_CONFIG 变量的作为认证的凭证。</p><p>注意：DOCKER_AUTH_CONFIG 是完成的 docker auth 凭证，也就是说，它应该和我们 ~/.docker/config.json 中的内容一致，例如：</p><pre class="language-text"><code> {
     &quot;auths&quot;: {
         &quot;registry.example.com&quot;: {
             &quot;auth&quot;: &quot;5oiR5piv5byg5pmL5rab&quot;
         }
     }
 }
</code></pre><p>简单的做法就是，我们在本地/服务器上执行 docker login 私有镜像源    登录成功后，将 ~/.docker/config.json 的文件内容直接复制，作为我们的变量的值</p><p>或者是  echo -n '用户名:密码' |base64 以这样的方式来获得 auth 的内容，组装成对应的格式，写入 GitLab 的 value 配置中</p><p>在生产环境中， CI 的耗时，我们当然是希望它可以尽可能的缩短， 那么我们除了上面 使用私有镜像源以外，我们还做了什么事情呢？</p><ol><li>构建自己的私有基础镜像
因为网络的原因， 如果默认使用官方镜像，
<ol><li>官方镜像拉不下来</li><li>在官方镜像中安装包耗时长</li><li>如果换源，需要每个 Dockerfile 都要做相同的事情。  这我们当然是不能同意的。 所以，我们构建了自己的私有镜像。 从busybox 开始 构建 alpine linux 使用私有源， 以此为基础 构建我们所需要的其他镜像。 用户不再需要自行换源
这个操作完成后， 原先我们需要在 ci 执行的过程中安装 py-pip (为了安装 docker-compose 和我们的服务依赖) 耗时从 3min30s 减少到了 18s</li></ol></li></ol><p>这里，需要说下为何我们是从头开始构建镜像，而不是基于官方镜像。  主要是为了减少镜像体积 以及为了更快的适用于我们的需求。<br>
同样的，我们构建了基础的 docker 镜像，python/maven 等镜像，都是默认使用了我们的私有源，并且，用户在使用时， 并不需要关注换源的事情， 减少用户的心智负担
接下来，我们在规范 Dockerfile 的编写。 减少不必要的依赖安装等，即减少网络耗时，也会缩小镜像体积</p><p>接下来的优化， 在于 job 的拆分， gitlab runner 可以使用tag 来使不同的runner 执行对应tag 下的job。 使用这种方式 可以便于分摊压力</p><p>另外的优化，在于使用 cache</p><p>CI 的构建中，大多数的镜像，其实变化不大，所以使用cache 可以成倍的提升 CI 的速度。  最后，分享一下 可能遇到的坑</p><p>前面提到了 service 中可以使用各种各样的服务， 无论是 dind 还是 mysql redis 等。 但是 如果我们全部做到了优化，都使用我们的私有源， 那便会发现问题</p><p>因为 gitlab ci 默认对于 docker:dind 的service  其实会选择连名为docker 的host ，以及 2375 端口。 当使用私有镜像源的时候，  比如</p><pre class="language-text"><code>services:
    - name: registry.docker-cn.com/taobeier/docker:stable-dind
</code></pre><p>那这个service 的host 是什么呢？
这个service 的host 其实是会变成 registry.docker-cn.com__taobeier__docker ，然后 gitlab runner 便会找不到， job 就会执行失败</p><p>有两种解决办法。 一种是 加一个变量</p><pre class="language-text"><code>variables:
  
  DOCKER_HOST: &quot;tcp://registry.docker-cn.com__taobeier__docker:2375&quot;
</code></pre><pre class="language-text"><code>services:
    - name: registry.docker-cn.com/taobeier/docker:stable-dind
      alias: docker
</code></pre><p>加一个 alias 。 这个方法目前很少人在用， 毕竟网络上查到的都是第一种 ，但是这个方式却是最简单的</p><p>好了， 由于时间的关系，今儿就先分享这么多， CI 系统上能做的事情有很多， 优化方面能做的事情也不少。  感谢大家</p><p>Q&amp;A
Q. 您提到 把各种依赖都以 service 的提供，请问是以哪种方式呢？  比如python的依赖，怎么做成service呢？
A： service 化的依赖，主要是指 类似 db / mysql/ reids 之类的。 或者是 dind 其实它提供的是 2375 端口的TCP服务。  Python 的依赖，我推荐的做法是， 构建一个 换了源的 Python 镜像。 安装依赖的时候，耗时会少很多。 或者说， 可以在定义 pipeline 的时候， 将虚拟环境的 venv 文件夹作为 cache ，之后的安装也会检查这个，避免不必要的安装。</p></div></div></div><div class="v-card__actions"><div class="flex xs12"><a href="/BLOG/tags/gitlab"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">gitlab</span></span></a><a href="/BLOG/tags/ci"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">ci</span></span></a><a href="/BLOG/tags/docker"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">docker</span></span></a></div></div></article></div><div class="flex text-xs-left xs6"><a href="/BLOG/posts/Promise.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text"><i class="fa mr-1 fa-chevron-left"></i>Prev</div><div class="title mt-1 primary--text hidden-xs-only">Promise $q</div></div></a></div><div class="flex text-xs-right xs6"><a href="/BLOG/posts/ast.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text">Next
          <i class="fa ml-1 fa-chevron-right"></i></div><div class="title mt-1 primary--text hidden-xs-only">抽象语法树(Abstract Syntax Tree)</div></div></a></div><div class="flex mt-3 xs12"><div class="v-card v-sheet theme--light"><div class="v-card__title"><span class="headline">Comment</span></div></div></div></div></div><footer class="v-footer blog-footer darken-1 mt-3 theme--dark" style="height:auto;"><div class="primary--text text--lighten-4 text-xs-center py-3 card-cont v-card v-card--flat v-sheet v-sheet--tile theme--dark primary"><div class="v-card__text pb-0">博客内容遵循 <a rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div><div class="v-card__text pt-0 mt-1"><span>訾绍飞 © 2015 - 2020</span><span><!---->
        Power by
        <a href="https://vuepress.vuejs.org" target="_blank" rel="noopener noreferrer">VuePress</a> Theme
        <a href="https://github.com/ShaofeiZi/BLOG" target="_blank" rel="noopener noreferrer">indigo</a></span></div></div></footer></div></main><button type="button" class="v-btn v-btn--bottom v-btn--floating v-btn--fixed v-btn--right theme--light accent" style="display:none;"><div class="v-btn__content"><i class="fa fa-lg fa-chevron-up"></i></div></button></div></div></div>
    <script src="/BLOG/assets/js/app.0f06c689.js" defer></script><script src="/BLOG/assets/js/8.8d991ea8.js" defer></script>
  </body>
</html>
