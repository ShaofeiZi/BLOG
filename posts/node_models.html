<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>node模块 · ShaofeiZi Blog · 做个日常记录</title>
    <meta name="description" content="訾绍飞的博客。万物皆有裂缝处，那是光射进来的地方。">
    <link rel="shortcut icon" href="/BLOG/favicon.ico">
  <link rel="manifest" href="/BLOG/manifest.json">
  <meta name="theme-color" content="#3F51B5">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <link rel="apple-touch-icon" href="/BLOG/icons/192.png">
  <link rel="mask-icon" href="/BLOG/icons/safari-pinned-tab.svg" color="#3eaf7c">
  <meta name="msapplication-TileImage" content="/icons/192.png">
  <meta name="msapplication-TileColor" content="#3F51B5">
    
    <link rel="preload" href="/BLOG/assets/css/styles.0f06c689.css" as="style"><link rel="preload" href="/BLOG/assets/js/app.0f06c689.js" as="script"><link rel="preload" href="/BLOG/assets/js/20.a8cf0c8f.js" as="script"><link rel="prefetch" href="/BLOG/assets/js/1.63593f8f.js"><link rel="prefetch" href="/BLOG/assets/js/10.fdd39873.js"><link rel="prefetch" href="/BLOG/assets/js/11.8a622b5e.js"><link rel="prefetch" href="/BLOG/assets/js/12.e9c56306.js"><link rel="prefetch" href="/BLOG/assets/js/13.20e44605.js"><link rel="prefetch" href="/BLOG/assets/js/14.eb804906.js"><link rel="prefetch" href="/BLOG/assets/js/15.47582e90.js"><link rel="prefetch" href="/BLOG/assets/js/16.0861cf41.js"><link rel="prefetch" href="/BLOG/assets/js/17.417e8e0e.js"><link rel="prefetch" href="/BLOG/assets/js/18.2318cd37.js"><link rel="prefetch" href="/BLOG/assets/js/19.997f9e1c.js"><link rel="prefetch" href="/BLOG/assets/js/2.73ec8147.js"><link rel="prefetch" href="/BLOG/assets/js/21.88823ca0.js"><link rel="prefetch" href="/BLOG/assets/js/22.a2e20a79.js"><link rel="prefetch" href="/BLOG/assets/js/23.e7d1e135.js"><link rel="prefetch" href="/BLOG/assets/js/24.492e8390.js"><link rel="prefetch" href="/BLOG/assets/js/25.b31904c7.js"><link rel="prefetch" href="/BLOG/assets/js/26.36e1cf84.js"><link rel="prefetch" href="/BLOG/assets/js/27.94b05a58.js"><link rel="prefetch" href="/BLOG/assets/js/28.bdcf9b24.js"><link rel="prefetch" href="/BLOG/assets/js/29.e41d34d2.js"><link rel="prefetch" href="/BLOG/assets/js/3.a4d6da98.js"><link rel="prefetch" href="/BLOG/assets/js/30.ba1f5d39.js"><link rel="prefetch" href="/BLOG/assets/js/31.2bd2d3d8.js"><link rel="prefetch" href="/BLOG/assets/js/32.824499f7.js"><link rel="prefetch" href="/BLOG/assets/js/33.58645df0.js"><link rel="prefetch" href="/BLOG/assets/js/34.334e4a83.js"><link rel="prefetch" href="/BLOG/assets/js/35.aa96d72d.js"><link rel="prefetch" href="/BLOG/assets/js/36.40c509d3.js"><link rel="prefetch" href="/BLOG/assets/js/37.829377f5.js"><link rel="prefetch" href="/BLOG/assets/js/38.3b15ddc7.js"><link rel="prefetch" href="/BLOG/assets/js/39.87218167.js"><link rel="prefetch" href="/BLOG/assets/js/4.c66c6308.js"><link rel="prefetch" href="/BLOG/assets/js/40.63562db5.js"><link rel="prefetch" href="/BLOG/assets/js/41.168fcabb.js"><link rel="prefetch" href="/BLOG/assets/js/42.e8f3ecd2.js"><link rel="prefetch" href="/BLOG/assets/js/43.5eb65461.js"><link rel="prefetch" href="/BLOG/assets/js/44.41e08b42.js"><link rel="prefetch" href="/BLOG/assets/js/45.54b7df8d.js"><link rel="prefetch" href="/BLOG/assets/js/46.0a0de71e.js"><link rel="prefetch" href="/BLOG/assets/js/47.bd587f67.js"><link rel="prefetch" href="/BLOG/assets/js/48.f3af8d7e.js"><link rel="prefetch" href="/BLOG/assets/js/49.483980fa.js"><link rel="prefetch" href="/BLOG/assets/js/5.05c034ec.js"><link rel="prefetch" href="/BLOG/assets/js/50.f814132b.js"><link rel="prefetch" href="/BLOG/assets/js/51.477c87bb.js"><link rel="prefetch" href="/BLOG/assets/js/52.55f963c5.js"><link rel="prefetch" href="/BLOG/assets/js/53.9eafd57f.js"><link rel="prefetch" href="/BLOG/assets/js/54.be1ba528.js"><link rel="prefetch" href="/BLOG/assets/js/55.a0ef8049.js"><link rel="prefetch" href="/BLOG/assets/js/56.8e8dca35.js"><link rel="prefetch" href="/BLOG/assets/js/6.f61c2d7b.js"><link rel="prefetch" href="/BLOG/assets/js/7.acadab6a.js"><link rel="prefetch" href="/BLOG/assets/js/8.8d991ea8.js"><link rel="prefetch" href="/BLOG/assets/js/9.efa09c0d.js">
    <link rel="stylesheet" href="/BLOG/assets/css/styles.0f06c689.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div data-app="true" id="app" class="application theme--light"><div class="application--wrap"><div role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" class="v-progress-linear blog-progress" style="height:3px;display:none;"><div class="v-progress-linear__background accent" style="height:3px;opacity:0.4;width:100%;"></div><div class="v-progress-linear__bar"><!----><div class="v-progress-linear__bar__determinate accent" style="width:0%;"></div></div></div><aside class="v-navigation-drawer v-navigation-drawer--close v-navigation-drawer--fixed v-navigation-drawer--is-mobile theme--light" style="height:100%;margin-top:0px;transform:translateX(-240px);width:240px;"><div><div class="aside-brand-wrap"><div class="aside-brand"><a href="/BLOG/" class="aside-avatar elevation-2 router-link-active"><img src="/BLOG/face.png" alt="avatar"></a><hgroup class="mt-3 variant-hide"><div class="subheading white--text">訾绍飞</div><a href="mailto:zishaofei221@gmail.com" title="zishaofei221@gmail.com" class="aside-mail primary--text text--lighten-5">zishaofei221@gmail.com</a></hgroup></div></div><hr class="v-divider theme--dark"><div role="list" class="v-list nav-list theme--light"><div role="listitem"><a href="/BLOG/" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-home"></i></div></div><div class="v-list__tile__content">首页</div></a></div><div role="listitem"><a href="/BLOG/tags" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-tag"></i></div></div><div class="v-list__tile__content">标签</div></a></div><div role="listitem"><a href="https://github.com/ShaofeiZi" target="_blank" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fab fa-github"></i></div></div><div class="v-list__tile__content">Github</div></a></div><div role="listitem"><a href="/BLOG/about" class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-user-secret"></i></div></div><div class="v-list__tile__content">About</div></a></div></div></div><div class="v-navigation-drawer__border"></div></aside><nav class="blog-toolbar v-toolbar v-toolbar--fixed theme--dark primary" style="margin-top:0px;padding-right:0px;padding-left:0px;transform:translateY(0px);"><div class="v-toolbar__content" style="height:56px;"><button type="button" class="v-btn v-btn--icon theme--dark"><div class="v-btn__content"><i class="fa fa-bars"></i></div></button><div class="v-toolbar__title">node模块</div><div class="spacer"></div><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""><!----></div><div class="v-menu v-menu--inline" style="display:none;"><div class="v-menu__activator"><button type="button" class="v-btn v-btn--icon theme--dark"><div class="v-btn__content"><i class="fa fa-share-alt"></i></div></button></div><div class="v-menu__content theme--light " style="max-height:auto;min-width:0px;max-width:auto;top:12px;left:0px;transform-origin:top right;z-index:0;display:none;"><div role="list" class="v-list theme--light"><div role="listitem"><a class="v-list__tile v-list__tile--link theme--light"><div class="v-list__tile__avatar"><div class="v-avatar" style="height:40px;width:40px;"><i class="fa fa-lg fa-copy"></i></div></div><div class="v-list__tile__title">复制链接</div></a></div></div><input type="text" tabindex="-1" aria-hidden="true" value="" class="fake-hide"></div></div></div></nav><main class="v-content" style="padding-top:56px;padding-right:0px;padding-bottom:0px;padding-left:0px;"><div class="v-content__wrap"><div class="container blog-container grid-list-xl align-center"><div class="layout row wrap"><div class="flex mb-3 xs12"><article class="v-card v-sheet theme--light elevation-16 post-card"><div class="v-card__title"><div class="flex xs12"><h2 class="display-1 mb-3">node模块</h2><div class="post-meta"><time datetime="2018-08-15T19:15:53.000Z" class="secondary--text post-time">2018年08月16日</time></div></div></div><div class="v-card__text pt-0 pb-0"><div class="flex xs12"><div class="content custom"><h1 id="node的模块化"><a href="#node的模块化" aria-hidden="true" class="header-anchor">#</a> node的模块化</h1><p>首先 假设 大家对 AMD CMD CommonJs 模块都有一定的了解 、
然后 我再说一下node用的CommonJs
nodeJS的根基就是ES  ES6之前 本身是没有模块机制的
所以出现了 CommonJs
</p><h2 id="commonjs"><a href="#commonjs" aria-hidden="true" class="header-anchor">#</a> CommonJs</h2><p>CommonJs 主要遵循三个约定</p><ul><li>require</li><li>模块上下文</li><li>模块标志
其他都是 次要的</li></ul><h3 id="require"><a href="#require" aria-hidden="true" class="header-anchor">#</a> require</h3><p>require本身就是一个函数 带一个参数  参数其实就是模块名（严谨点叫模块标志）返回值 是模块暴露的API
举个例子</p><pre class="language-javascript"><code><span class="token keyword">const</span> blahblah <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">&quot;boom_shakalaka&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>这样就能引用到这个模块中的暴露的东东</p><h3 id="模块上下文"><a href="#模块上下文" aria-hidden="true" class="header-anchor">#</a> 模块上下文</h3><p>在一个CommonJs的上下文中需要满足下面这些条件有这些条件存在</p><ul><li>require</li><li>exports  （连接异界的神魔之井）</li><li>module （挂着自带的属性  比如 ID exports）
module.exports的初始对象指向exports</li></ul><pre class="language-text"><code>module.exports=XXXXXX
</code></pre><p>然后module.exports就不等于exports了
<img src="/images/nodeModels/_1533119230_1606572170.png" alt>
三者 和外部模块的关系</p><h3 id="模块标志"><a href="#模块标志" aria-hidden="true" class="header-anchor">#</a> 模块标志</h3><p>通俗的讲  就是个模块名<br>
模块标识其实就是一个字符串，用于传给 require 函数的。
它需要是小驼峰格式的标识名，或者以 &quot;.&quot; 以及 &quot;..&quot; 带头的相对路径。理论上来说不应该带上后缀名，如 &quot;.js&quot;。</p><p>(官网说)[www.commonjs.org]</p><pre class="language-text"><code>Module Identifiers
A module identifier is a String of &quot;terms&quot; delimited by forward slashes.
A term must be a camelCase identifier, &quot;.&quot;, or &quot;..&quot;.
Module identifiers may not have file-name extensions like &quot;.js&quot;.
Module identifiers may be &quot;relative&quot; or &quot;top-level&quot;. A module identifier is &quot;relative&quot; if the first term is &quot;.&quot; or &quot;..&quot;.
Top-level identifiers are resolved off the conceptual module name space root.
Relative identifiers are resolved relative to the identifier of the module in which &quot;require&quot; is written and called.
</code></pre><p>实际在用的时候 好多人都不遵循规范
比如好多-cli。。。但是不符合标志啊</p><p>满足上面三个约定的 基本就可以认为是一个模块<br>
还有两个隐藏约定
不遵守 也可以ok 比如自己写的时候</p><ul><li>存储方案；</li><li>加载器可以支持环境变量寻径，也可以不支持。</li></ul><h3 id="存储方案；"><a href="#存储方案；" aria-hidden="true" class="header-anchor">#</a> 存储方案；</h3><p>模块内容存在数据库 文件 函数 链接库  都OK  比如node 就直接放文件系统   node_modules<br>
C++模块是用动态链接的  跳过</p><h3 id="加载器"><a href="#加载器" aria-hidden="true" class="header-anchor">#</a> 加载器</h3><p>设置一个path变量  然后通过path来查找  这个可以不实现  看心情   CommonJs管不到。。
再举个栗子</p><p><img src="/images/nodeModels/_a_1533121025_305852556.png" alt="a"></p><p>完成</p><h2 id="node的模块"><a href="#node的模块" aria-hidden="true" class="header-anchor">#</a> node的模块</h2><pre class="language-text"><code>node index.js
</code></pre><p>index.js 就是入口文件<br>
入口之后 都是一个一个模块组成 大部分是CommonJs规范  还有一些<code>.node</code>的文件 这些就是C++模块文件
有啥好处呢
配合npm2.X版本 是嵌套类型能精准控制依赖版本
3.0 扁平化依赖  为了控制体积
对于后端和CLI 更适合npm2.。</p><h3 id="寻找路径"><a href="#寻找路径" aria-hidden="true" class="header-anchor">#</a> 寻找路径</h3><p>之前说过  node中可以使用以 &quot;.&quot; 以及 &quot;..&quot; 带头的相对路径
在node在 大小写随便用其实也是可以的<br>
比如 https://gitlab.renrenche.com/fe/swagger-axios</p><ol><li>Node.js 核心模块</li><li>文件模块</li><li>三方模块</li><li>项目模块</li></ol><h4 id="核心模块-https-github-com-nodejs-node-tree-v6-9-4-lib"><a href="#核心模块-https-github-com-nodejs-node-tree-v6-9-4-lib" aria-hidden="true" class="header-anchor">#</a> (核心模块)[https://github.com/nodejs/node/tree/v6.9.4/lib]</h4><p>迭代有点快  放了个老的LTS版本</p><p>这些模块编译后会放到node的可执行文件中
而且 每一个文件都有一个预留标志<br>
自己写的  最好不要重名
不然只会返回核心模块的</p><h4 id="文件模块"><a href="#文件模块" aria-hidden="true" class="header-anchor">#</a> 文件模块</h4><p>通过路径的方式引入的模块</p><h5 id="三方模块"><a href="#三方模块" aria-hidden="true" class="header-anchor">#</a> 三方模块</h5><p>找到的是目录的话  会依次寻找  index.js  index.json index.node  然后返回</p><h5 id="项目模块"><a href="#项目模块" aria-hidden="true" class="header-anchor">#</a> 项目模块</h5><pre class="language-text"><code>比如一个 JavaScript 文件路径是 /Users/biu/index.js，那么在 require(&quot;/Users/biu&quot;) 的时候，该 JavaScript 文件会被加载。
</code></pre><p>如果package.json 的main字段指向的是  biu.js  会直接找到biu.js  而不会例会index.js</p><p><img src="/images/nodeModels/_1533122207_1535541421.png" alt></p><pre class="language-text"><code>// a_program.js

const Biu = require(&quot;biu&quot;);
// package.json 的部分源码
</code></pre><pre class="language-text"><code>{
  ...,
  &quot;main&quot;: &quot;biu.js&quot;,
  ...
}
</code></pre><h5 id="再说三方模块"><a href="#再说三方模块" aria-hidden="true" class="header-anchor">#</a> 再说三方模块</h5><p>传进去的标志 是<code>/</code> ,<code>./</code>,<code>../</code>这种 通常是依赖包的形式存在的<br>
node 不仅仅会在当前目录寻找</p><ol><li>当前文件目录的 node_modules 目录下；</li><li>若 1 没有符合的模块，则去当前文件目录的父目录的 node_modules 下；</li><li>若没有符合的模块，则再往上一层目录的 node_modules；</li><li>若没有符合的模块，重复 3 直到寻找到符合的模块或者根目录为止。</li></ol><p>其它的标识不是以 <code>/</code> ,<code>./</code>,<code>../</code>带头的模块被称为三方模块，这些模块通常以 Node.js 依赖包形式存在。</p><h5 id="模块缓存"><a href="#模块缓存" aria-hidden="true" class="header-anchor">#</a> 模块缓存</h5><p>node会缓存第一次加载的代码 第二次的时候 会直接返回缓存</p><pre class="language-text"><code>// dog.js

&quot;use strict&quot;;

let boom = &quot;嘘，蛋花汤&quot;;
boom += &quot;在睡觉。OOO&quot;;

module.exports = {
  &quot;OOO&quot;: boom
};
</code></pre><pre class="language-text"><code>// entry.js

&quot;use strict&quot;;

let ლ_ಠ益ಠ_ლ = require(&quot;./dog&quot;);

console.log(ლ_ಠ益ಠ_ლ);

let 蛋花汤 = require(&quot;./dog&quot;);

console.log(蛋花汤);
</code></pre><pre class="language-text"><code>$ node entry.js
{ 'OOO': '嘘，蛋花汤在睡觉。OOO' }
{ 'OOO': '嘘，蛋花汤在睡觉。OOO' }
</code></pre><h3 id="node包"><a href="#node包" aria-hidden="true" class="header-anchor">#</a> node包</h3><h4 id="包描述文件"><a href="#包描述文件" aria-hidden="true" class="header-anchor">#</a> 包描述文件</h4><p>package.json</p><h5 id="必填"><a href="#必填" aria-hidden="true" class="header-anchor">#</a> 必填</h5><p><img src="/images/nodeModels/_1533123592_1533676748.png" alt></p><h5 id="选填"><a href="#选填" aria-hidden="true" class="header-anchor">#</a> 选填</h5><p><img src="/images/nodeModels/_1533123608_258888695.png" alt></p><p>保留字段有：build，default，email，external，files，imports，maintainer，paths，platform，require，summary，test，using，downloads，uid，type。
其他可以写 但是会被包管理器忽略</p><p>node模块包描述引用的CommonJs的包描述</p><p>来个栗子CommonJs
<img src="/images/nodeModels/_1533123722_677683093.png" alt></p><p>node包描述</p><p><img src="/images/nodeModels/_1533123692_340428043.png" alt></p><p>具体可以看https://docs.npmjs.com/files/package.json</p><p>npm2 是嵌套的  npm3是扁平的<br>
举个栗子
举个例子，我们的项目有一个依赖包 bar 的 1.0.0 版本依赖另一个包 foo 的 ^1.0.0 版本，而我们项目的另一个依赖包 baz 的 1.0.0 版本依赖了 foo 的 ^1.1.0 版本
npm2</p><pre class="language-text"><code>└── node_modules
    ├── bar
    │   └── node_modules
    │       └── foo
    └── baz
        └── node_modules
            └── foo
</code></pre><pre class="language-text"><code>如果 bar 的开发者觉得 foo 中有一个函数无法满足自己的需求，那么也许它会有这么一段代码：

const foo = require(&quot;foo&quot;);

const old = foo.func;
foo.func = function() {
    // do some hack
    // 做一些注入式的代码，使其满足自己的要求
    // 但这段代码可能会引起其它使用该包的依赖
    // 造成破坏
};
</code></pre><p>在npm2 中 是两份不同的缓存  不会有问题
npm3+  就不知道会造成什么后果了 扁平化  适合面向体积优化  带来危险不可预知</p><pre class="language-text"><code>└── node_modules
    ├── bar
    └── foo
    └── baz
</code></pre><p>依赖爆炸。 对于想要开发node的来说  是个灾难。。</p><h5 id="循环引用"><a href="#循环引用" aria-hidden="true" class="header-anchor">#</a> 循环引用</h5><p>假如一不小心，a 引用 b，b 又引用了 a 这种
a和b都加载完成了
那是没什么问题的  因为加载的时候 都已经加载完成了
如果没有加载完成 a没加载完  加载b  OK   这个时候b又去加载a  炸了。。
如果只是单独一个函数<br>
那就用到的时候再去加载</p><pre class="language-text"><code>// a.js
const b = require(&quot;b&quot;);

// 做一些事情...
</code></pre><pre class="language-text"><code>// b.js
exports.test = function() {
    const a = require(&quot;a&quot;);
};
</code></pre><h3 id="cnpm"><a href="#cnpm" aria-hidden="true" class="header-anchor">#</a> cnpm</h3><p>和npm的工作原理不一样 会将包缓存到node_modules\npminstall这个目录下 然后再以软连接的形式（windows上是快捷方式）链接到项目目录。
这样会导致一个问题。所有的包都只有一份实体。
因为缓存是根据路径缓存的。然后拿的路径是软连接。所以每次拿的缓存是单独的，</p><p>cnpm4.2和4.3的区别和npm2与npm3项目目录很像。
但是为了服务后端服务人员。是先按照npm2的方法存放一份包。然后再把相关依赖按照npm3的方法再放一份包。
这样解决了前端开发人员和后端开发人员 对不同包管理器的依赖喜好</p><h2 id="node-模块加载原理"><a href="#node-模块加载原理" aria-hidden="true" class="header-anchor">#</a> node 模块加载原理</h2><p>nodejs载入一个模块或者C++扩展是依赖require来加载的 （ES6的先不管）
先说一下<a href="https://github.com/nodejs/node/blob/v6.9.4/src/node_main.cc" target="_blank" rel="noopener noreferrer">nodejs的入口</a></p><pre class="language-text"><code>// src/node_main.cc
int main(int argc, char *argv[]) {
  // Disable stdio buffering, it interacts poorly with printf()
  // calls elsewhere in the program (e.g., any logging from V8.)
  setvbuf(stdout, nullptr, _IONBF, 0);
  setvbuf(stderr, nullptr, _IONBF, 0);
  // 直接进入node命名空间，然后调用start函数
  return node::Start(argc, argv);
}
</code></pre><p>然后门去node里<a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L3470" target="_blank" rel="noopener noreferrer">看一下</a></p><pre class="language-text"><code>
// Execute the lib/internal/bootstrap_node.js file which was included as a
// static C string in node_natives.h by node_js2c.
// 'internal_bootstrap_node_native' is the string containing that source code.
// 进入之后启动bootstrap_node  进行初始化
Local&lt;String&gt; script_name = FIXED_ONE_BYTE_STRING(env-&gt;isolate(),
                                                &quot;bootstrap_node.js&quot;);
Local&lt;Value&gt; f_value = ExecuteString(env, MainSource(env), script_name);

...

Local&lt;Function&gt; f = Local&lt;Function&gt;::Cast(f_value);

...

f-&gt;Call(Null(env-&gt;isolate()), 1, &amp;arg);
</code></pre><p>bootstrap_node.js其实是一个大闭包的函数
在上面那段代码会把process对象给注入进去<a href="https://github.com/nodejs/node/blob/v6.9.4/lib/internal/bootstrap_node.js" target="_blank" rel="noopener noreferrer"></a></p><pre class="language-text"><code>(function(process) {
...

})
</code></pre><p><img src="/images/nodeModels/_1533262790_1843766525.png" alt>
大概的一个启动流程。。
在node中其实是有四类模块</p><ul><li>C++核心</li><li>node内置</li><li>用户源码</li><li>C++扩展</li></ul><p>之前讲的时候C++核心 和 node内置 都是node和核心模块 用户源码和C++扩展都是属于文件模块</p><p>node 是原生模块
先介绍下Binding函数<br><a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2609" target="_blank" rel="noopener noreferrer">对应的是</a></p><pre class="language-text"><code>其中 Local&lt;String&gt; module = args[0]-&gt;ToString(env-&gt;isolate()); 和 node::Utf8Value module_v(env-&gt;isolate(), module); 两句代码意味着从参数中获得文件标识（或者也可以认为是文件名）的字符串并赋值给 module_v。
</code></pre><pre class="language-text"><code>在得到标识字符串之后，Node.js 将通过 node_module* mod = get_builtin_module(*module_v); 这段代码获取 C++ 核心模块，例如未经源码 lib 目录下的 JavaScript 文件封装的 file 模块。我们注意到这里获取核心模块用的是一个叫 get_builtin_module 函数，这个函数内部做的工作就是在一条叫 modlist_builtin 的 C++ 核心模块链表上进行对比文件标识，从而返回相应的模块。
</code></pre><pre class="language-text"><code>追根溯源，这些 C++ 核心模块则是在 node_module_register 函数中被逐一注册进链表里面的。
</code></pre><p><a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.cc#L2378-L2405" target="_blank" rel="noopener noreferrer">node_module_register</a></p><pre class="language-c"><code><span class="token keyword">extern</span> <span class="token string">&quot;C&quot;</span> <span class="token keyword">void</span> <span class="token function">node_module_register</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_module</span><span class="token operator">*</span> mp <span class="token operator">=</span> reinterpret_cast<span class="token operator">&lt;</span><span class="token keyword">struct</span> <span class="token class-name">node_module</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>mp<span class="token operator">-&gt;</span>nm_flags <span class="token operator">&amp;</span> NM_F_BUILTIN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    mp<span class="token operator">-&gt;</span>nm_link <span class="token operator">=</span> modlist_builtin<span class="token punctuation">;</span>
    modlist_builtin <span class="token operator">=</span> mp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node_is_initialized<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// &quot;Linked&quot; modules are included as part of the node project.</span>
    <span class="token comment">// Like builtins they are registered *before* node::Init runs.</span>
    <span class="token comment">//“链接”模块作为节点项目的一部分包含在内。</span>
    <span class="token comment">//与内置类似，它们在* node :: Init运行之前注册*。</span>
    mp<span class="token operator">-&gt;</span>nm_flags <span class="token operator">=</span> NM_F_LINKED<span class="token punctuation">;</span>
    mp<span class="token operator">-&gt;</span>nm_link <span class="token operator">=</span> modlist_linked<span class="token punctuation">;</span>
    modlist_linked <span class="token operator">=</span> mp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    modpending <span class="token operator">=</span> mp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">node_module</span><span class="token operator">*</span> <span class="token function">get_builtin_module</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">node_module</span><span class="token operator">*</span> mp<span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>mp <span class="token operator">=</span> modlist_builtin<span class="token punctuation">;</span> mp <span class="token operator">!=</span> nullptr<span class="token punctuation">;</span> mp <span class="token operator">=</span> mp<span class="token operator">-&gt;</span>nm_link<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>mp<span class="token operator">-&gt;</span>nm_modname<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token function">CHECK</span><span class="token punctuation">(</span>mp <span class="token operator">==</span> nullptr <span class="token operator">||</span> <span class="token punctuation">(</span>mp<span class="token operator">-&gt;</span>nm_flags <span class="token operator">&amp;</span> NM_F_BUILTIN<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span>mp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre><p><a href="https://github.com/nodejs/node/blob/v6.9.4/src/node.h#L458-L484" target="_blank" rel="noopener noreferrer">注册核心模块的宏</a></p><pre class="language-c"><code><span class="token macro property">#<span class="token directive keyword">define</span> NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, priv, flags)    \
  extern &quot;C&quot; {                                                        \
    static node::node_module _module =                                \
    {                                                                 \
      NODE_MODULE_VERSION,                                            \
      flags,                                                          \
      NULL,                                                           \
      __FILE__,                                                       \
      NULL,                                                           \
      (node::addon_context_register_func) (regfunc),                  \
      NODE_STRINGIFY(modname),                                        \
      priv,                                                           \
      NULL                                                            \
    };                                                                \
    NODE_C_CTOR(_register_ ## modname) {                              \
      node_module_register(&amp;_module);                                 \
    }                                                                 \
  }</span>

<span class="token macro property">#<span class="token directive keyword">define</span> NODE_MODULE(modname, regfunc)                                 \
  NODE_MODULE_X(modname, regfunc, NULL, 0)</span>

<span class="token macro property">#<span class="token directive keyword">define</span> NODE_MODULE_CONTEXT_AWARE(modname, regfunc)                   \
  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, NULL, 0)</span>

<span class="token macro property">#<span class="token directive keyword">define</span> NODE_MODULE_CONTEXT_AWARE_BUILTIN(modname, regfunc)           \
  NODE_MODULE_CONTEXT_AWARE_X(modname, regfunc, NULL, NM_F_BUILTIN)   \
</span></code></pre><p>关键的宏：<code>NODE_MODULE_CONTEXT_AWARE_BUILTIN</code> 注册进核心模块
<a href="https://github.com/nodejs/node/blob/v6.9.4/src/node_file.cc#L1511" target="_blank" rel="noopener noreferrer">node_file.cc</a>
// node_file.cc 最后一行</p><pre class="language-c"><code><span class="token function">NODE_MODULE_CONTEXT_AWARE_BUILTIN</span><span class="token punctuation">(</span>fs<span class="token punctuation">,</span> node<span class="token operator">::</span>InitFs<span class="token punctuation">)</span>
</code></pre><p>也就是说，基本上在每个 C++ 核心模块的源码末尾都有有一个宏调用将该模块注册进 C++ 核心模块的链表当中去，以供 process.binding 进行获取。</p><p>有兴趣的  可以研究下  没兴趣的可以略过</p><h3 id="nodejs-内置模块"><a href="#nodejs-内置模块" aria-hidden="true" class="header-anchor">#</a> nodejs 内置模块</h3><p>FS HTTP 等、基本等同于API  是放在lib目录下的那些  基本是对核心模块的一个高级封装
如 ·<code>lib/crypto.js</code>中就有一段 <code>const binding = process.binding(&quot;crypto&quot;);</code>这样的代码，它的很多内容都是基于 C++ 核心模块中的 crypto 进行实现的。
js文件也是编译到可执行文件的</p><p><img src="/images/nodeModels/_1533269278_2142443112.png" alt></p><p>内置模块的相关处理<br>
如果是native_module  那就返回那个类
不然就进入 compile  进行编译<br>
看到第一行 获取这个模块的源码
直接返回_source[id]
这个其实是直接返回bing</p><pre class="language-c"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcmp</span><span class="token punctuation">(</span><span class="token operator">*</span>module_v<span class="token punctuation">,</span> <span class="token string">&quot;natives&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  exports <span class="token operator">=</span> Object<span class="token operator">::</span><span class="token function">New</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span><span class="token function">isolate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">DefineJavaScript</span><span class="token punctuation">(</span>env<span class="token punctuation">,</span> exports<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cache<span class="token operator">-&gt;</span><span class="token function">Set</span><span class="token punctuation">(</span>module<span class="token punctuation">,</span> exports<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><p>然后再看下<a href="https://github.com/nodejs/node/blob/v6.9.4/src/node_javascript.cc#L23-L36" target="_blank" rel="noopener noreferrer">DefineJavaScript</a></p><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">DefineJavaScript</span><span class="token punctuation">(</span>Environment<span class="token operator">*</span> env<span class="token punctuation">,</span> Local<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  HandleScope <span class="token function">scope</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span><span class="token function">isolate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> native <span class="token operator">:</span> natives<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>native<span class="token punctuation">.</span>source <span class="token operator">!=</span> internal_bootstrap_node_native<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Local<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> name <span class="token operator">=</span> String<span class="token operator">::</span><span class="token function">NewFromUtf8</span><span class="token punctuation">(</span>env<span class="token operator">-&gt;</span><span class="token function">isolate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> native<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
      Local<span class="token operator">&lt;</span>String<span class="token operator">&gt;</span> source <span class="token operator">=</span>
          String<span class="token operator">::</span><span class="token function">NewFromUtf8</span><span class="token punctuation">(</span>
              env<span class="token operator">-&gt;</span><span class="token function">isolate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> reinterpret_cast<span class="token operator">&lt;</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>native<span class="token punctuation">.</span>source<span class="token punctuation">)</span><span class="token punctuation">,</span>
              NewStringType<span class="token operator">::</span>kNormal<span class="token punctuation">,</span> native<span class="token punctuation">.</span>source_len<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ToLocalChecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      target<span class="token operator">-&gt;</span><span class="token function">Set</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>大概返回结果就是这样的</p><pre class="language-text"><code>{ fs: &quot;fs 的源码&quot;, http: &quot;http 的源码&quot; }
</code></pre><p>native这个变量并没有在这里<br>
可以看一下node-gyp的配置文件   然后有个node_js2c  在这一步里面做的事情就是用 Python 去调用一个叫 tools/js2c.py 的文件。而这个 js2c.py 就是问题的关键所在了
<a href="https://github.com/nodejs/node/blob/v6.9.4/tools/js2c.py" target="_blank" rel="noopener noreferrer">js2c</a>
这个文件会生成 src/node_natives.h 这个头文件 然后就存在了
<img src="/images/nodeModels/_1533279346_1183074135.png" alt></p><p>大概是这样
把传说中编译进 Node.js 二进制文件的 JavaScript 代码的神秘面纱揭开以后，我们现在回到 NativeModule.compile 函数中来。它会在刚获取到的内置模块 JavaScript 源码字符串前后用 (function (exports, require, module, __filename, __dirname) { 和 }); 进行包裹，形成一段闭包代码，然后将其放入 vm6 （安全沙箱）中运行，并传入事先准备好的 module 和 exports 对象供其导出。</p><pre class="language-javascript"><code><span class="token comment">// a.js</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

exports<span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>test <span class="token operator">=</span> test<span class="token punctuation">;</span>
</code></pre><pre class="language-javascript"><code><span class="token comment">// 编译后</span>
<span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">exports<span class="token punctuation">,</span> require<span class="token punctuation">,</span> module<span class="token punctuation">,</span> __filename<span class="token punctuation">,</span> __dirname</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

exports<span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
exports<span class="token punctuation">.</span>test <span class="token operator">=</span> test<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><pre class="language-c"><code><span class="token comment">// compile 执行</span>
<span class="token comment">// this 就是 NativeModule 类实例化出来的一个对象</span>
fn <span class="token operator">=</span> 刚才编译后得到的闭包函数<span class="token punctuation">;</span>
<span class="token function">fn</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>exports， NativeModule<span class="token punctuation">.</span>require<span class="token punctuation">,</span> this<span class="token punctuation">,</span> this<span class="token punctuation">.</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>大概的一个包的require的过程</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这里的Module是NativeModule 我们自己写的是另一个module 只不过共用了一个闭包的源码。</p></div><p>举个例子  写个a.js
然后console.log(Module)</p><pre class="language-javascript"><code>Module <span class="token punctuation">{</span>
  id<span class="token operator">:</span> <span class="token string">'.'</span><span class="token punctuation">,</span>
  exports<span class="token operator">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  parent<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  filename<span class="token operator">:</span> <span class="token string">'/private/tmp/temp/a.js'</span><span class="token punctuation">,</span>
  loaded<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
  children<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  paths<span class="token operator">:</span>
   <span class="token punctuation">[</span> <span class="token string">'/private/tmp/temp/node_modules'</span><span class="token punctuation">,</span>
     <span class="token string">'/private/tmp/node_modules'</span><span class="token punctuation">,</span>
     <span class="token string">'/private/node_modules'</span><span class="token punctuation">,</span>
     <span class="token string">'/node_modules'</span> <span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code></pre><p>可以看出来 exports 只是其中一小部分
但是这部分是我们用的最多的</p><h3 id="用户源码模块"><a href="#用户源码模块" aria-hidden="true" class="header-anchor">#</a> 用户源码模块</h3><p>非node源码模块的js模块
运行时 按照需求  加载进来的
每个模块也会被加上这个闭包的头尾
具体的实现可以看<a href="https://github.com/nodejs/node/blob/v6.9.4/lib/module.js#L37" target="_blank" rel="noopener noreferrer">module</a>
我们平时用的require就是这个模块中的require函数
module类的实例对象  就是用户源码模块的真正本体。在VM运行的结果 就是核心
我们平时写的module.exports就是这个的一个实例对象。
module就是这个类 实例化之后的对象
当我们写 <code>module.exports = foo</code> 的时候就是给这个 module 对象的 exports 变量重新赋了个值。</p><p>看下require函数吧 直接去调用module._load</p><p>然后表示不是入口模块
<img src="/images/nodeModels/_1533280856_375899372.png" alt><img src="/images/nodeModels/_1533280928_1991339377.png" alt></p><p>整体流程是
<img src="/images/nodeModels/_1533280961_2055754391.png" alt>
加载模块我们省略了 因为他是调用 trymoduleload来执行的  其实就是loan函数加了错误处理
根据不同文件名选择不同加载方式</p><pre class="language-c"><code>Module<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>load <span class="token operator">=</span> <span class="token function">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  this<span class="token punctuation">.</span>filename <span class="token operator">=</span> filename<span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>paths <span class="token operator">=</span> Module<span class="token punctuation">.</span><span class="token function">_nodeModulePaths</span><span class="token punctuation">(</span>path<span class="token punctuation">.</span><span class="token function">dirname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  var extension <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">extname</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'.js'</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>Module<span class="token punctuation">.</span>_extensions<span class="token punctuation">[</span>extension<span class="token punctuation">]</span><span class="token punctuation">)</span> extension <span class="token operator">=</span> <span class="token string">'.js'</span><span class="token punctuation">;</span>
  Module<span class="token punctuation">.</span>_extensions<span class="token punctuation">[</span>extension<span class="token punctuation">]</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
  this<span class="token punctuation">.</span>loaded <span class="token operator">=</span> true<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>说一下JS的吧</p><p>Module._extensions[&quot;.js&quot;] 这种规则做的事情分两步：</p><ol><li>同步读取源码（filename）的内容，使用 fs.readFileSync；</li><li>调用 module._compile() 函数编译源码并执行。</li></ol><p><img src="/images/nodeModels/_1533281181_199652954.png" alt></p><p>这个函数也是生成闭包代码 然后执行</p><p><img src="/images/nodeModels/_1533281211_1197741264.png" alt></p><p>一个模块的源码 经过编译之后 就形成了 携带<code>expotr</code>、<code>require</code>,<code>filename</code>,<code>dirname</code>的一个函数了  这就是我们平时能直接用这些东西的原因了</p><p>node加载  window类似dll  linux 类似动态链接库</p><p><img src="/images/nodeModels/_1533283596_2073200717.png" alt></p><p>最后我再给大家一个小技巧，改造 <code>require()</code> 函数的规则，比如大家的项目目录下有个 <code>lib/test/a.js</code> 文件，然后可以让大家在项目的任意文件中直接通过 <code>require(&quot;lib/test/a&quot;)</code> 就能获取这个模块，而不用去自行计算相对路径值绕来绕去</p></div></div></div><div class="v-card__actions"><div class="flex xs12"><a href="/BLOG/tags/CommonJs"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">CommonJs</span></span></a><a href="/BLOG/tags/node"><span tabindex="0" class="v-chip capitalize chip-tag v-chip--label v-chip--small theme--light"><span class="v-chip__content">node</span></span></a></div></div></article></div><div class="flex text-xs-left xs6"><a href="/BLOG/posts/git-demo.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text"><i class="fa mr-1 fa-chevron-left"></i>Prev</div><div class="title mt-1 primary--text hidden-xs-only">Git学习手册</div></div></a></div><div class="flex text-xs-right xs6"><a href="/BLOG/posts/RxjsEventBus.html" class="post-nav v-btn v-btn--flat v-btn--router theme--light"><div class="v-btn__content"><div class="grey--text">Next
          <i class="fa ml-1 fa-chevron-right"></i></div><div class="title mt-1 primary--text hidden-xs-only">通过Rxjs五行代码实现EventBus</div></div></a></div><div class="flex mt-3 xs12"><div class="v-card v-sheet theme--light"><div class="v-card__title"><span class="headline">Comment</span></div></div></div></div></div><footer class="v-footer blog-footer darken-1 mt-3 theme--dark" style="height:auto;"><div class="primary--text text--lighten-4 text-xs-center py-3 card-cont v-card v-card--flat v-sheet v-sheet--tile theme--dark primary"><div class="v-card__text pb-0">博客内容遵循 <a rel="license noopener noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></div><div class="v-card__text pt-0 mt-1"><span>訾绍飞 © 2015 - 2020</span><span><!---->
        Power by
        <a href="https://vuepress.vuejs.org" target="_blank" rel="noopener noreferrer">VuePress</a> Theme
        <a href="https://github.com/ShaofeiZi/BLOG" target="_blank" rel="noopener noreferrer">indigo</a></span></div></div></footer></div></main><button type="button" class="v-btn v-btn--bottom v-btn--floating v-btn--fixed v-btn--right theme--light accent" style="display:none;"><div class="v-btn__content"><i class="fa fa-lg fa-chevron-up"></i></div></button></div></div></div>
    <script src="/BLOG/assets/js/app.0f06c689.js" defer></script><script src="/BLOG/assets/js/20.a8cf0c8f.js" defer></script>
  </body>
</html>
