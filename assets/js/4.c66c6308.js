(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{241:function(e,n,t){"use strict";t.r(n);var r=t(2),o=Object(r.a)({},(function(){var e=this.$createElement;this._self._c;return this._m(0)}),[function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"_1-渲染dom元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-渲染dom元素","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.渲染DOM元素")]),t("blockquote",[t("p",[e._v("让我们开始一步步构建自己的React。")])]),t("h2",{attrs:{id:"_1-1-dom审查"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-dom审查","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.1 DOM审查")]),t("p",[e._v("在我们开始之前，让我们回顾一下我们将使用的DOM API：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('// 根据ID获取对应元素\nconst domRoot = document.getElementById("root");\n// 根据标签名创建一个对应的新元素\nconst domInput = document.createElement("input");\n// 设置属性\ndomInput["type"] = "text";\ndomInput["value"] = "Hi world";\ndomInput["className"] = "my-class";\n// 监听事件\ndomInput.addEventListener("change", e => alert(e.target.value));\n// 创建文本节点\nconst domText = document.createTextNode("");\n// 设置文本节点内容\ndomText["nodeValue"] = "Foo";\n// 增加元素\ndomRoot.appendChild(domInput);\n// 增加文本节点（与之前相同）\ndomRoot.appendChild(domText);\n')])]),t("p",[e._v("请注意，我们正在设置"),t("a",{attrs:{href:"https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html",target:"_blank",rel:"noopener noreferrer"}},[e._v("元素属性而不是属性")]),e._v("。这意味着只允许有效的属性。")]),t("h2",{attrs:{id:"_1-2-freact-元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-freact-元素","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.2 FReact 元素")]),t("p",[e._v("我们用原生的JS对象来描述需要渲染的东西。就叫他FReact Elements。")]),t("p",[e._v("这些元素有两个必需的属性："),t("code",[e._v("type")]),e._v("和"),t("code",[e._v("props")]),e._v("。")]),t("ul",[t("li",[t("p",[t("code",[e._v("type")]),e._v("可以是一个 "),t("strong",[e._v("{字符串string}")]),e._v("  或一个 "),t("strong",[e._v("{函数function}")]),e._v(", 但我们将只使用 "),t("strong",[e._v("字符")]),e._v("，直到我们在稍后的帖子中引入 "),t("strong",[e._v("组件")]),e._v("。")])]),t("li",[t("p",[t("code",[e._v("props")]),e._v("是可以为空的对象（但不为空）。props可能有一个"),t("code",[e._v("children")]),e._v("属性，它应该是一个"),t("code",[e._v("FReact")]),e._v("元素的数组。")])])]),t("blockquote",[t("p",[e._v("我们会很多地使用FReact Elements，所以从现在开始我们只会称它们为 "),t("strong",[e._v("{元素element}")]),e._v(", 不要与HTML element混淆.")])]),t("p",[e._v("例如，像这样的一个元素：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const element = {\n  type: "div",\n  props: {\n    id: "container",\n    children: [\n      { type: "input", props: { value: "foo", type: "text" } },\n      { type: "a", props: { href: "/bar" } },\n      { type: "span", props: {} }\n    ]\n  }\n};\n')])]),t("p",[e._v("描述这个dom:")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<div id="container">\n  <input value="foo" type="text">\n  <a href="/bar"></a>\n  <span></span>\n</div>\n')])]),t("hr"),t("p",[e._v("FReact-元素与React-元素非常相似。")]),t("p",[e._v("但是通常你在使用React时不会创建React-元素作为JS对象，")]),t("p",[e._v("你可能使用JSX或者甚至是createElement。")]),t("p",[e._v("我们将在FReact中做同样的事情，但我们将会在系列下一篇文章中描述 "),t("code",[e._v("createElement")]),e._v(" 的代码。")]),t("hr"),t("h2",{attrs:{id:"_1-3-渲染-dom-元素"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-渲染-dom-元素","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.3 渲染-DOM-元素")]),t("p",[e._v("下一步是将元素及其子元素呈现给dom。")]),t("p",[e._v("我们将使用一个render函数（相当于ReactDOM.render）接收一个元素和一个dom容器。")]),t("p",[e._v("该函数应该创建由element定义的dom子树并将其附加到容器中：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function render(element, parentDom) {\n  const { type, props } = element; // 获取类型 和 属性对象\n  const dom = document.createElement(type); // 创建-类型-element\n  const childElements = props.children || []; // 获取-孩子\n  childElements.forEach(childElement => render(childElement, dom)); // 每个孩子 都要加入-爸爸妈妈-的怀抱\n  //\n  parentDom.appendChild(dom); // 爸爸妈妈加入爷爷奶奶的怀抱\n}\n")])]),t("p",[e._v("我们仍然缺少属性和事件监听器。让我们props用Object.keys函数迭代属性名称并相应地-设置-它们：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function render(element, parentDom) {\n  const { type, props } = element;\n  const dom = document.createElement(type);\n\n  const isListener = name => name.startsWith("on");\n  // 是否开头-on\n  Object.keys(props).filter(isListener).forEach(name => {\n    const eventType = name.toLowerCase().substring(2); // 取两位后\n    dom.addEventListener(eventType, props[name]);\n  });\n  // 每一个开头-on 的属性-对应-函数 props[name] - >用-dom-addEvent 接连\n\n  const isAttribute = name => !isListener(name) && name != "children";\n  // 不是-监听事件 和 不能是-孩子\n\n  Object.keys(props).filter(isAttribute).forEach(name => {\n    dom[name] = props[name];\n  });\n // 过滤出来的属性 - 赋予 - > dom\n  const childElements = props.children || [];\n  childElements.forEach(childElement => render(childElement, dom));\n\n  parentDom.appendChild(dom);\n}\n')])]),t("h2",{attrs:{id:"_1-4-渲染dom文本节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-渲染dom文本节点","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.4 渲染DOM文本节点")]),t("p",[t("code",[e._v("render")]),e._v("函数不支持的一件事是文本节点。首先，我们需要定义文本元素的外观。例如，"),t("span",[e._v("Foo")]),e._v("在React中描述的元素如下所示：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const reactElement = {\n  type: "span",\n  props: {\n    children: ["Foo"] // 是孩子, 但也只是一个字符串\n  }\n};\n')])]),t("p",[e._v("请注意，"),t("code",[e._v("children")]),e._v("，只是一个字符串 ，而不是另一个元素对象。")]),t("p",[e._v("这违背了我们如何定义FReact元素：children应该是元素的数组和所有元素应该有type和props。")]),t("p",[e._v("如果我们遵循这些规则，我们将来会少一些if判断。")]),t("p",[e._v("因此，FReact Text Elements将type==“TEXT ELEMENT”相等，实际文本将位于nodeValue属性中。")]),t("p",[e._v("就像：")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const textElement = {\n  type: "span",\n  props: {\n    children: [\n      {\n        type: "TEXT ELEMENT", // 1\n        props: { nodeValue: "Foo" } // 2\n      }\n    ]\n  }\n')])]),t("p",[e._v("现在我们已经规范了文本元素的数据结构，我们需要可以呈现它, 以便与其他元素一样，而区别也就是"),t("code",[e._v('{type: "TEXT ELEMENT"}')]),e._v("。\n我们应该使用"),t("code",[e._v("createTextNode")]),e._v("，而不是使用"),t("code",[e._v("createElement")]),e._v("。")]),t("p",[e._v("就是这样，"),t("code",[e._v("nodeValue")]),e._v("将会像其他属性一样设置。")]),t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('function render(element, parentDom) {\n  const { type, props } = element;\n\n  // 创建DOM元素\n  const isTextElement = type === "TEXT ELEMENT"; // 文本类型判定\n  const dom = isTextElement\n    ? document.createTextNode("")\n    : document.createElement(type);\n\n  // 增加事件监听\n  const isListener = name => name.startsWith("on");\n  Object.keys(props).filter(isListener).forEach(name => {\n    const eventType = name.toLowerCase().substring(2);\n    dom.addEventListener(eventType, props[name]);\n  });\n\n  // 设置属性\n  const isAttribute = name => !isListener(name) && name != "children";\n  Object.keys(props).filter(isAttribute).forEach(name => {\n    dom[name] = props[name];\n  });\n\n  // 渲染子节点\n  const childElements = props.children || [];\n  childElements.forEach(childElement => render(childElement, dom));\n\n  // 增加到父节点\n  parentDom.appendChild(dom);\n}\n')])]),t("h1",{attrs:{id:"_1-5-概要"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-概要","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.5 概要")]),t("p",[e._v("我们创建了一个"),t("code",[e._v("render")]),e._v("函数，允许我们将一个元素"),t("code",[e._v("{element}")]),e._v("及其子元素"),t("code",[e._v("{children}")]),e._v("呈现给DOM "),t("code",[e._v("parentDom.appendChild(dom)")]),e._v("。")]),t("p",[e._v("接下来我们需要的是"),t("code",[e._v("createElement")]),e._v("的简单方法。")]),t("p",[e._v("我们将在下一篇文章中做到这一点，在那里我们将让JSX与FReact一起工作。")]),t("p",[e._v("如果您想尝试我们迄今为止编写的代码，请检查"),t("a",{attrs:{href:"https://codepen.io/shaofeizi/pen/oNvLRwm",target:"_blank",rel:"noopener noreferrer"}},[e._v("codepen")]),e._v(".你也可以从github回购中检查这个差异。")])])}],!1,null,null,null);n.default=o.exports}}]);